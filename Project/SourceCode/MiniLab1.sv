//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

module MiniLab1(

    //////////// CLOCK //////////
    input                                  clk,				// default is 50 MHz

    //////////// KEY //////////
    input                                  RST_n,			// asynchronized active low reset from push button
        
    //////////// WE ///////////
    input                [9:0]             SW,

    //////////// LED //////////
    output        reg    [9:0]             LEDR,

    //////////// GPIO_1, GPIO_1 connect to GPIO Default //////////
    inout                                  TX,
    inout                                  RX
);

//=======================================================
//  REG/WIRE declarations
//=======================================================
    wire rst_n;                		// synchronized active low reset
    wire [15:0] addr;            	// dst_EX_DM, result from ALU
    wire [15:0] rdata;            	// exteral data input from the switches, 16'hDEAD if addr != 16'hC001
    wire [15:0] wdata;            	// data from cpu that will reflect on LEDs if addr == 16'hC000 during write
    wire update_LED;            	// update LED status if addr == 16'hC000 and we is set
    wire [7:0] spart_databus;       // databus for communcation with spart
    wire re, we;					// read enable and write enable from proc
	wire spart_cs_n;				// active low chip select signal for spart

//=======================================================
//  Structural coding
//=======================================================
	// If no external memory mapped device is used, put 16'hDEAD on rdata
    assign rdata = ((addr == 16'hC001) & re) ? {6'b000000, SW} :			// 16'hC001 maps to switches, only lower 10 bits are used since only 10 SWs
                   (addr[15:2]==14'h3001 & re) ? {8'h00,spart_databus} :	// 16'hC004 - 16'hC007 maps to spart's bidirectional data bus
				   16'hDEAD;        
 
    assign spart_databus = (addr[15:2]==14'h3001 & we) ? wdata[7:0] : 8'hzz;		// spart databus traffic control

	assign spart_cs_n = ~(addr[15:2]==14'h3001 & (we | re));				// enable spart only when addr is correct and either read or write is enabled

    assign update_LED = (addr == 16'hC000) & we;            // make testbench more straight forward, LEDs map to 16'hC000

    // Considering LED as a "memory", so picked negedge trigged flops
    always @(negedge clk, negedge rst_n)
        if(!rst_n)
            LEDR <= 10'h000;                	// LED output default to all OFF
        else if (update_LED)
            LEDR <= wdata[9:0];                	// data is 16 bit, but only have 10 LEDs, use lower bits

//=======================================================
//  Initialize modules
//=======================================================
    // push button input synchronization
    rst_synch irst_synch(
		.RST_n(RST_n),
		.clk(clk),
		.rst_n(rst_n)
	);

    // iCPU
    cpu iCPU(
		.clk(clk),
		.rst_n(rst_n),
		.rdata(rdata),
		.addr(addr),
		.re(re),
		.we(we),
		.wdata(wdata)
	);

    // spart transmittion protocol
    spart iSPART(
		.clk(clk),
		.rst_n(rst_n),
		.iocs_n(spart_cs_n),
		.iorw_n(~we),			// read on high, write on low
		.tx_q_full(),			// not used because proc should read status register to "access" this value
		.rx_q_empty(),			// not used because proc should read status register to "access" this value
		.ioaddr(addr[1:0]),
		.databus(spart_databus),
		.TX(TX),
		.RX(RX)
	);

endmodule
