
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

module BMP_display_sim(


	//////////// CLOCK //////////
	input 		          		clk,
	input						VGA_CLK,

	//////////// KEY //////////
	input 						RST_n,	// this is KEY[0]

	//////////// LED //////////
	output reg	     [9:0]		LEDR,

	//////////// VGA //////////
	output		          		VGA_BLANK_N,
	output		     [7:0]		VGA_B,
	//output		          		VGA_CLK,
	output		     [7:0]		VGA_G,
	output		          		VGA_HS,
	output		     [7:0]		VGA_R,
	output		          		VGA_SYNC_N,
	output		          		VGA_VS,

    //////////// SW ///////////
    input                [9:0]             SW,

	//////////// GPIO_1, GPIO_1 connect to GPIO Default //////////
    inout                                  TX,
    inout                                  RX
);

	////////////////////////////////////
	// internal nets for connections //
	//////////////////////////////////
	wire rst_n;							// synchronized global reset signal
	//wire clk;							// 50MHz clock from PLL
	wire pll_locked;					// PLL is locked on reference clock
	wire [9:0] xpix;					// current X coordinate of VGA
	wire [8:0] ypix;					// current Y coordinate of VGA
	wire [18:0] raddr;					// address into videoMem for reads
	wire [8:0] vga_rdata;				// 9-bit color
	wire [18:0] waddr;					// write address to videoMem
	wire [8:0] vga_wdata;				// write data to videoMem
	reg  [9:0] xloc;
	reg  [8:0] yloc;
	wire vga_we;

	// [13:0] ctrl
	// add_fnt - ctrl[13]     add a character
	// fnt_indx - ctrl[12:7]  one of 42 characters // 0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ =>,()
	// add_img - ctrl[6]      pulse high for one clock to add image
	// rem_img - ctrl[5]      pulse high for one clock to remove image
	// image_indx - ctrl[4:0] index of image in image memory (32 possible)
	wire [13:0] ctrl;

	///////////////////////////////////////////////
	// More definitions inherited from MiniLab1 //
	/////////////////////////////////////////////
    wire [15:0] addr;            	// dst_EX_DM, result from ALU
    wire [15:0] rdata;            	// exteral data input from the switches, 16'hDEAD if addr != 16'hC001
    wire [15:0] wdata;            	// data from cpu that will reflect on LEDs if addr == 16'hC000 during write
    wire update_LED;            	// update LED status if addr == 16'hC000 and we is set
    wire [7:0] spart_databus;       // databus for communcation with spart
    wire re, we;					// read enable and write enable from proc
	wire spart_cs_n;				// active low chip select signal for spart
/*
	////////////////////////////////////////////////////////
	// Instantiate PLL to generate clk and 25MHz VGA_CLK //
	//////////////////////////////////////////////////////
	PLL iPLL(.refclk(REF_CLK), .rst(~RST_n),.outclk_0(clk),.outclk_1(VGA_CLK),
		   .locked(pll_locked));
*/
	/////////////////////////////////////
	// instantiate rst_n synchronizer //
	///////////////////////////////////
	rst_synch iRST(.clk(clk),.RST_n(RST_n), .pll_locked(1'b1), .rst_n(rst_n));


	///////////////////////////////////////
	// Instantiate VGA Timing Generator //
	/////////////////////////////////////
	VGA_timing iVGATM(.clk25MHz(VGA_CLK), .rst_n(rst_n), .VGA_BLANK_N(VGA_BLANK_N),
					.VGA_HS(VGA_HS),.VGA_SYNC_N(VGA_SYNC_N), .VGA_VS(VGA_VS), 
					.xpix(xpix), .ypix(ypix), .addr_lead(raddr));
					
	/////////////////////////////////////
	// Instantiate 9-bit video memory //
	///////////////////////////////////
	videoMem ivideoMem(.clk(clk),.we(vga_we),.waddr(waddr),.wdata(vga_wdata),.raddr(raddr),.rdata(vga_rdata));

	assign VGA_R = {vga_rdata[8:6],5'b00000};
	assign VGA_G = {vga_rdata[5:3],5'b00000};
	assign VGA_B = {vga_rdata[2:0],5'b00000};

	//////////////////////////////////////////////
	// Instantiate Logic that determines pixel //
	// colors based on BMP placement          //
	///////////////////////////////////////////					
	PlaceBMP iPlaceBMP(.clk(clk),.rst_n(rst_n),.ctrl(ctrl),
		   .xloc(xloc),.yloc(yloc),.waddr(waddr),.wdata(vga_wdata),.we(vga_we));

	///////////////////////////////////////////////////////////
	// Memory map control signals of PlaceBMP to processor  //
	//		ctrl - 0xC008								   //
	//		xloc - 0xC009								  //
	//		yloc - 0xC00A								 //
	//		WRITE ONLY!!!								//
	//		SHOULD SET xloc and yloc prior to ctrl	   //
	////////////////////////////////////////////////////
	assign ctrl = (addr == 16'hC008 && we) ? wdata[13:0] : 14'h0000;

	always_ff @(posedge clk, negedge rst_n)
	if(!rst_n)
		xloc <= 10'h000;
	else if(addr == 16'hC009 && we)
		xloc <= wdata[9:0];

	always_ff @(posedge clk, negedge rst_n)
	if(!rst_n)
		yloc <= 9'h000;
	else if(addr == 16'hC00A && we)
		yloc <= wdata[8:0];

//=======================================================
//  Code below are inherited from MiniLab1
//=======================================================

//=======================================================
//  Structural coding
//=======================================================
	// If no external memory mapped device is used, put 16'hDEAD on rdata
    assign rdata = ((addr == 16'hC001) & re) ? {6'b000000, SW} :			// 16'hC001 maps to switches, only lower 10 bits are used since only 10 SWs
                   (addr[15:2]==14'h3001 & re) ? {8'h00,spart_databus} :	// 16'hC004 - 16'hC007 maps to spart's bidirectional data bus
				   16'hDEAD;        
 
    assign spart_databus = (addr[15:2]==14'h3001 & we) ? wdata[7:0] : 8'hzz;		// spart databus traffic control

	assign spart_cs_n = ~(addr[15:2]==14'h3001 & (we | re));				// enable spart only when addr is correct and either read or write is enabled

    assign update_LED = (addr == 16'hC000) & we;            // make testbench more straight forward, LEDs map to 16'hC000

    // Considering LED as a "memory", so picked negedge trigged flops
    always @(negedge clk, negedge rst_n)
        if(!rst_n)
            LEDR <= 10'h000;                	// LED output default to all OFF
        else if (update_LED)
            LEDR <= wdata[9:0];                	// data is 16 bit, but only have 10 LEDs, use lower bits

//=======================================================
//  Initialize modules
//=======================================================
    // iCPU
    cpu iCPU(
		.clk(clk),
		.rst_n(rst_n),
		.rdata(rdata),
		.addr(addr),
		.re(re),
		.we(we),
		.wdata(wdata)
	);

    // spart transmittion protocol
    spart iSPART(
		.clk(clk),
		.rst_n(rst_n),
		.iocs_n(spart_cs_n),
		.iorw_n(~we),			// read on high, write on low
		.tx_q_full(),			// not used because proc should read status register to "access" this value
		.rx_q_empty(),			// not used because proc should read status register to "access" this value
		.ioaddr(addr[1:0]),
		.databus(spart_databus),
		.TX(TX),
		.RX(RX)
	);

endmodule
